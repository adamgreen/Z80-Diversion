/* Copyright 2023 Adam Green (https://github.com/adamgreen/)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
; Use the RP2040's PIO state machines to interface with the Z80.

; State machine code to toggle the Z80 CLOCK pin, detect MREQ'/IOREQ' requests, use the two shift registers to read the
; Z80's address bits and then send them to the CPU.
;
; Side Set will need to be configured for the Shift_Clock and Shift_Latch pins.
;   They should be initialized with:
;       Shift_Clock low & Shift_Latch high.
; Set will need to be configured for the Z80 CLK signal.
;   Z80 CLK should be initialized to low.
; INPUT pins to Shift_Even, Shift_Odd, MREQ', IOREQ'.
; JMP conditional pin should be set to RFSH'.
; ISR should be configured for auto push with a threshold of 18. Left shift through ISR. This leaves the address in
;   the lower 16-bits and the MREQ and IOREQ (not inverted) in bits 16 and 17.
; OSR should be configured for right shift and no auto pull.
.program z80_clk_mreq_ioreq

; Will use side set for the Shift_Clock and Shift_Latch signals.
.side_set 2

.wrap_target
next_z80_cycle:
    ; Rising edge of Z80 CLK.
    ; Add a single cycle delay to allow MREQ' to de-assert itself.
    set pins, 1 side 0b10 [1]

    ; Don't need to check MREQ' and IOREQ' signals if RFSH' pin is asserted.
    jmp pin, rfsh_not_asserted side 0b10
    ; Z80 CLK should be kept low and then high for 2x8+10=26 state machine cycles before looping around for
    ; next Z80 cycle.
    nop side 0b10 [3]
null_cycle:
    set x, 7 side 0b10 [1]
high_loop:
    jmp x--, high_loop side 0b10 [1]
    jmp clock_low side 0b10

    ; RFSH' isn't asserted so check to see if either MREQ' or IOREQ' are low.
rfsh_not_asserted:
    ; Load IOREQ':MREQ':Shift_Odd:Shift_Even pin state into OSR shift register.
    mov osr, !pins side 0b10
    ; Discard Shift_Odd and Shift_Even
    out null, 2 side 0b10
    ; Place IOREQ and MREQ into X register.
    out x, 2 side 0b10
    ; If neither MREQ or IOREQ are asserted then we don't have a memory or I/O request to process.
    jmp !x, null_cycle side 0b10

    ; Have a request so read out the 16-bit address value using the two shift registers.
process_address:
    ; Place MREQ and IOREQ (Hi if asserted) from X in ISR shift register.
    ; Falling edge of Shift_Latch to latch the address bits.
    in x, 2 side 0b00

    ; Set X up for 8x2 bit address shift loop.
    ; Pull the Shift_Latch pin back high now that the latest address has been latched to prepare for shifting it out.
    set x, 7 side 0b10
shift_loop:
    ; Clocking out the address bits on falling edges of Shift_Clock.
    in pins, 2 side 0b10
    ; Rising edge of Shift_Clock.
    jmp x--, shift_loop side 0b11

    ; Signal the second state machine to start waiting for the RD' or WR' signal to be asserted.
    irq 1 rel side 0b10

    ; Keep Z80 CLK low for 2x8+10=26 state machine cycles to match high state while shifting out address bits.
clock_low:
    set pins, 0 side 0b10 [4]
    set x, 7 side 0b10 [4]
clk_low_loop:
    jmp x--, clk_low_loop side 0b10 [1]
.wrap




; State machine code to detect RD'/WR' requests. It will assert the WAIT' signal for reads while it waits for the CPU
; to return the requested 8-bit data.
;
; Side Set will need to be configured for the WAIT' signal.
;   It should be initialized in the high, un-asserted state.
; INPUT pins to RD', WR', D0-D7, M1'.
; OUTPUT pins to D0-D7.
; ISR should be configured for left shift and auto push with a threshold of 2+8+1=13.
; OSR should be configured for right shift with no auto pull.
.program z80_rd_wr

; Will use side set for the WAIT' signal.
.side_set 1

.wrap_target
next_request:
    ; Wait for the first state machine program to signal the IRQ indicating that a transfer has started.
    wait 1 irq 0 rel side 1

    ; Wait for RD' or WR' to be asserted.
loop:
    ; Load RD', WR', D0-D7, M1' pin state into OSR shift register.
    ; Invert the bits so that RD' and WR' both being un-asserted will result in 0b00, instead of 0b11.
    mov osr, !pins side 1
    ; Place RD and WR into X register.
    out x, 2 side 1
    ; If RD and WR are both 0 then keep looping.
    jmp !x, loop side 1

    ; RD or WR was asserted.
    ; Read the pin states into ISR and have them auto pushed up to the CPU.
    ; Assert WAIT' signal while processing read or write request.
    in pins, 11 side 0

    ; Wait for CPU to send read/write response bits.
    pull side 0
    ; CPU will send 0babcdefghxxxxxxxx so that it can be used for setting pindirs to input or output and then set
    ; D0-D7 with the specific value which will not be written out to Z80 if pindirs are configured as input.
    out pindirs, 8 side 0
    out pins, 8 side 0
    ; CPU will send 0b00000000XXXXXXXXXXXXXXXX to contain the "WAIT 1 GPIO nn" instruction to execute and then bits to
    ; restore pindirs to
    pull side 0
    ; De-assert WAIT' signal and wait for RD' or WR' to be de-asserted (set high).
    out exec, 16 side 1
    ; Make D0-D7 pins input again before wrapping around and waiting for the next transfer.
    out pindirs, 8 side 1
    ; Clear any extra address read IRQs that have occurred since this read/write transfer started.
    irq clear 0 rel side 1
.wrap
